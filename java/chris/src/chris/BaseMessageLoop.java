package chris;

import java.util.logging.Level;
import java.util.logging.Logger;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayDeque;
import message.Msg_AppTermination;
import message.BaseMessage;

/**
 * Базовый предок очереди сообщений обработчика или целого приложения.
 * @author su
 */
abstract public class BaseMessageLoop {
    
    /** Если в очереди больше записей чем порог, метод put_in_queue() ждет. */
    final static int ПОРОГ_ЗАПОЛНЕНИЯ_ОЧЕРЕДИ = 250;

    //^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v
    //
    //                            Методы внешнего интерфейса
    //
    //v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^

    /**
     * Цикл выборки из очереди и обработки сообщений - основной цикл обработчика или целого
     * приложения. Синхронизация не нужна, т.к. петля исполняется только одной нитью.
     */
    public void go() {

        _послеЗапуска_();
        
        // основной цикл
        while(true) {
            
            //
            // ждем появления сообщения в очереди и извлекаем его
            //
            BaseMessage сообЩение = извлечь_блокируя();

            //
            // отрабатываем извлеченное сообщение
            //
            if      // объект без явного указания адресата? разобраться чего он хочет и исполнить
                    (сообЩение.handler_class==null)
                if      // принята заявка закрытия приложения? выходим
                        (сообЩение instanceof Msg_AppTermination)
                {
                    _передЗавершением_();
                    break;
                }
                else    // иначе, сообщение направлено самому обработчику
                    _роднаяОбработкаСообщения_(сообЩение);
            else   // иначе, вызвать функтор для обработки сообщения
                try {
                    // иначе, вызвать функтор для обработки сообщения
                    invokeFunctor(сообЩение);
                } catch (Crash ex) {
                    Logger.getLogger(BaseMessageLoop.class.getName()).log(Level.SEVERE,
                            "Ошибка в функторе при обработке им сообщения " + сообЩение.getClass().getName(), ex);
                }
        }   // Основной цикл
    }   // go()

    /**
     * Показывает пуста ли очередь сообщений.
     * @return true/false
     */
    public synchronized  boolean очередь_пуста() {
        return очередьСообщений.isEmpty();
    }
    
    /**
     * Получить размер очереди сообщений.
     * @return
     */
    public synchronized int размер_очереди() {
        return очередьСообщений.size();
    }

    /**
     * Поместить сообщение в начало очереди. Для приоритетных сообщений.
     * @param сообщениеХризолита помещаемое в очередь сообщение.
     */
    public synchronized void put_in_the_head_of_queue(BaseMessage сообщениеХризолита) {
        очередьСообщений.addFirst(сообщениеХризолита);
        notifyAll();
    }

    /**
     * Поместить сообщение в конец очереди.
     * @param сообщениеХризолита помещаемое в очередь сообщение.
     */
    public synchronized void put_in_queue(BaseMessage сообщениеХризолита) {
        
        while (очередьСообщений.size() > ПОРОГ_ЗАПОЛНЕНИЯ_ОЧЕРЕДИ) {
            try {
                флагОжиданияПостановкиВОчередь = true;
                wait();
            } catch (InterruptedException ex) {
                флагОжиданияПостановкиВОчередь = false;
            }
        }

        очередьСообщений.addLast(сообщениеХризолита);
        notifyAll();
    }
    private boolean флагОжиданияПостановкиВОчередь = false;
    
    /**
     * Дождаться когда в очереди появится сообщение извлечь из начала очереди.
     * @return сообщение или null, если очередь пуста
     */
    public synchronized BaseMessage извлечь_блокируя() {
        // ждать появления сообщения
        while(очередьСообщений.isEmpty()) {
            try {
                wait();
            } catch (InterruptedException ex) {}
        }

        // Взять из очереди сообщение
        BaseMessage сооб = очередьСообщений.pollFirst();

        // Возможно, метод put_in_queue ждет. Толкнуть его.
        if
                (флагОжиданияПостановкиВОчередь && очередьСообщений.size()<ПОРОГ_ЗАПОЛНЕНИЯ_ОЧЕРЕДИ)
            notifyAll();        

        return сооб;
    }
    
    /**
     * Извлечь сообщение из начала очереди, если оно имеется.
     * @return сообщение или null, если очередь пуста
     */
    public synchronized BaseMessage извлечь_не_блокируя() {
        return очередьСообщений.isEmpty()? null: очередьСообщений.pollFirst();
    }

    /**
     * Запросить остановку нити.
     */
    public synchronized void остановить() {
        put_in_queue(new Msg_AppTermination());
    }

    //~~~$$$~~~$$$~~~$$$~~~$$$~~~$$$~~~$$$~~~$$$~~~$$$~~~$$$~~~$$$~~~$$$~~~$$$~~~$$$~~~$$$
    //
    //                                  Наследуемый интерфейс
    //
    //~~~$$$~~~$$$~~~$$$~~~$$$~~~$$$~~~$$$~~~$$$~~~$$$~~~$$$~~~$$$~~~$$$~~~$$$~~~$$$~~~$$$

    //---$$$---$$$---$$$---$$$---$$$ protected переменные ---$$$---$$$---$$$---$$$---$$$--

    //---$$$---$$$---$$$---$$$---$$$--- protected методы ---$$$---$$$---$$$---$$$---$$$---

    /**
     * Специальная обработка потомка по завершению работы нити.
     */
    protected void _послеЗапуска_() {};

    /**
     * Специальная обработка потомка по завершению работы нити.
     */
    protected void _передЗавершением_() {};
    
    /**
     * Когда в поле адресата сообщения стоит null, подразумевается отдать это сообщение
     * на распознание обработку объекту петли сообщений, а не функтору.
     * @param сообЩение сообщение без указания адресата.
     */
    abstract protected void _роднаяОбработкаСообщения_(BaseMessage сообЩение);
    
    //---$$$---$$$---$$$---$$$---$$$--- protected классы ---$$$---$$$---$$$---$$$---$$$---

    //###%%%###%%%###%%%###%%%###%%%###%%%###%%%###%%%###%%%###%%%###%%%###%%%###%%%###%%%
    //
    //                               Внутренний интерфейс
    //
    //###%%%###%%%###%%%###%%%###%%%###%%%###%%%###%%%###%%%###%%%###%%%###%%%###%%%###%%%

    //---%%%---%%%---%%%---%%%--- private переменные ---%%%---%%%---%%%---%%%---%%%---%%%
    
    /** Главная очередь сообщений обработчика. Очередь очень быстрая. Это кольцевой буфер. */
    private ArrayDeque<BaseMessage> очередьСообщений = new ArrayDeque<BaseMessage>();
    
    //---%%%---%%%---%%%---%%%---%%% private методы ---%%%---%%%---%%%---%%%---%%%---%%%--

    /**
     *  Вызвать функтор, для обработки сообщения, извлеченного из очереди.
     * <p>Функтор - это класс со статическим методом "обработать". Он, обычно,
     * содержится в сообщении в поле "Адресат".
     * @param message
     */
    private void invokeFunctor(BaseMessage message) {

        // выделить статический метод "обработать" функтора
        Method методОбработатьФунктора = null;      // сюда поместим объект, представляющий вызываемый метод
        try {
            методОбработатьФунктора = message.handler_class.getMethod("go",       // имя метода функтора, пришедшего в поле "Адресат" сообщения
                    new Class[] {       // типы параметров, которые будут передаваться методу
                        BaseMessage.class
                    }        
            );
        } catch (NoSuchMethodException ex) {
            throw new Crash("Error while invoking functor " + message.handler_class + ".go()", ex);
        }   // try   // try

        // вызвать его, передав ему как параметр пришедшее сообщение
        try {
            методОбработатьФунктора.invoke(
                    null,               // метод статическийобъект, нет объекта, которому он принадлежит
                    message         // сообщение, передаваемое методу в качестве параметра
            );
        } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException ex) {
            throw new Crash("Error while invoking functor " + message.handler_class + ".go()", ex);
        }
    }   // void ВызватьФунктор()

    //---%%%---%%%---%%%---%%%---%%% private классы ---%%%---%%%---%%%---%%%---%%%---%%%--
    
}   // class ПетляСообщений
